(window.webpackJsonp=window.webpackJsonp||[]).push([[320],{1640:function(_,v,t){_.exports=t.p+"assets/img/img031.d23011be.png"},2406:function(_,v,t){"use strict";t.r(v);var r=t(54),a=Object(r.a)({},(function(){var _=this,v=_.$createElement,r=_._self._c||v;return r("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[r("h1",{attrs:{id:"第四节-垃圾回收器-了解"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#第四节-垃圾回收器-了解"}},[_._v("#")]),_._v(" 第四节 垃圾回收器 [了解]")]),_._v(" "),r("h2",{attrs:{id:"_1、串行垃圾回收器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1、串行垃圾回收器"}},[_._v("#")]),_._v(" 1、串行垃圾回收器")]),_._v(" "),r("p",[_._v("串行：在一个线程内执行垃圾回收操作。")]),_._v(" "),r("p",[_._v("新生代串行回收器 SerialGC：采用复制算法实现，单线程垃圾回收，独占式垃圾回收器")]),_._v(" "),r("p",[_._v("老年代串行回收器 SerialOldGC：采用标记压缩算法，单线程独占式垃圾回收器")]),_._v(" "),r("h2",{attrs:{id:"_2、并行垃圾回收器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2、并行垃圾回收器"}},[_._v("#")]),_._v(" 2、并行垃圾回收器")]),_._v(" "),r("p",[_._v("并行：在多个线程中执行垃圾回收操作。")]),_._v(" "),r("p",[_._v("新生代 ParNew 回收器：采用复制算法实现，多线程回收器，独占式垃圾回收器。")]),_._v(" "),r("p",[_._v("新生代 ParallelScavengeGC 回收器：采用复制算法多线程独占式回收器")]),_._v(" "),r("p",[_._v("老年代 ParallelOldGC 回收器: 采用标记压缩算法，多线程独占式回收器")]),_._v(" "),r("ul",[r("li",[r("p",[_._v("CMS回收器")]),_._v(" "),r("p",[_._v("CMS全称 (Concurrent Mark Sweep)，是一款并发的、使用标记-清除算法的垃圾回收器。对CPU资源非常敏感。"),r("br")]),_._v(" "),r("p",[_._v("启用CMS回收器参数 ：-XX:+UseConcMarkSweepGC。"),r("br")]),_._v(" "),r("p",[_._v("使用场景：GC过程短暂停顿，适合对时延要求较高的服务，用户线程不允许长时间的停顿。"),r("br")]),_._v(" "),r("p",[_._v("优点：最短回收停顿时间为目标的收集器。并发收集，低停顿。"),r("br")]),_._v(" "),r("p",[_._v("缺点：服务长时间运行，造成严重的内存碎片化。算法实现比较复杂。")])]),_._v(" "),r("li",[r("p",[_._v("G1回收器")]),_._v(" "),r("p",[_._v("G1(Garbage-First)是一款面向服务端应用的并发垃圾回收器, 主要目标用于配备多颗CPU的服务器，治理大内存。是JDK1.7提供的一个新收集器，是当今收集器技术发展的最前沿成果之一。"),r("br")]),_._v(" "),r("p",[_._v("G1计划是并发标记-清除收集器的长期替代品。"),r("br")]),_._v(" "),r("p",[_._v("启用G1收集器参数：-XX:+UseG1GC启用G1收集器。"),r("br")]),_._v(" "),r("p",[_._v("G1将整个Java堆划分为多个大小相等的独立区域(Region)，虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了, 它们都是一部分Region(不需要连续)的集合。")]),_._v(" "),r("p",[r("img",{attrs:{src:t(1640),alt:"images"}})]),_._v(" "),r("p",[_._v("每块区域既有可能属于Old区、也有可能是Young区，因此不需要一次就对整个老年代/新生代回收。而是当线程并发寻找可回收的对象时，有些区块包含可回收的对象要比其他区块多很多。虽然在清理这些区块时G1仍然需要暂停应用线程，但可以用相对较少的时间优先回收垃圾较多的Region(这也是G1命名的来源)。这种方式保证了G1可以在有限的时间内获取尽可能高的收集效率。"),r("br")]),_._v(" "),r("p",[_._v("特点：")]),_._v(" "),r("ul",[r("li",[r("p",[_._v("一整块堆内存被分成多个独立的区域Regions")])]),_._v(" "),r("li",[r("p",[_._v("存活对象被拷贝到新的Survivor区")])]),_._v(" "),r("li",[r("p",[_._v("新生代内存由一组不连续的堆heap区组成，使得可以动态调整各个区域")])]),_._v(" "),r("li",[r("p",[_._v("多线程并发GC")])]),_._v(" "),r("li",[r("p",[_._v("young GC会有STW（Stop the world）事件")])])])])]),_._v(" "),r("h2",{attrs:{id:"_3、垃圾回收器对比"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3、垃圾回收器对比"}},[_._v("#")]),_._v(" 3、垃圾回收器对比")]),_._v(" "),r("h3",{attrs:{id:"_1新生代回收器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1新生代回收器"}},[_._v("#")]),_._v(" ①新生代回收器")]),_._v(" "),r("table",[r("thead",[r("tr",[r("th",[_._v("名称")]),_._v(" "),r("th",[_._v("串行/并行/并发")]),_._v(" "),r("th",[_._v("回收算法")]),_._v(" "),r("th",[_._v("适用场景")]),_._v(" "),r("th",[_._v("可以与CMS配合")])])]),_._v(" "),r("tbody",[r("tr",[r("td",[_._v("SerialGC")]),_._v(" "),r("td",[_._v("串行")]),_._v(" "),r("td",[_._v("复制")]),_._v(" "),r("td",[_._v("单CPU")]),_._v(" "),r("td",[_._v("是")])]),_._v(" "),r("tr",[r("td",[_._v("ParNewGC")]),_._v(" "),r("td",[_._v("并行")]),_._v(" "),r("td",[_._v("复制")]),_._v(" "),r("td",[_._v("多CPU")]),_._v(" "),r("td",[_._v("是")])]),_._v(" "),r("tr",[r("td",[_._v("ParallelScavengeGC")]),_._v(" "),r("td",[_._v("并行")]),_._v(" "),r("td",[_._v("复制")]),_._v(" "),r("td",[_._v("多CPU且关注吞吐量")]),_._v(" "),r("td",[_._v("否")])])])]),_._v(" "),r("h3",{attrs:{id:"_2老年代回收器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2老年代回收器"}},[_._v("#")]),_._v(" ②老年代回收器")]),_._v(" "),r("table",[r("thead",[r("tr",[r("th",[_._v("名称")]),_._v(" "),r("th",[_._v("串行/并行/并发")]),_._v(" "),r("th",[_._v("回收算法")]),_._v(" "),r("th",[_._v("适用场景")])])]),_._v(" "),r("tbody",[r("tr",[r("td",[_._v("SerialOldGC")]),_._v(" "),r("td",[_._v("串行")]),_._v(" "),r("td",[_._v("标记压缩")]),_._v(" "),r("td",[_._v("单CPU")])]),_._v(" "),r("tr",[r("td",[_._v("ParNewOldGC")]),_._v(" "),r("td",[_._v("并行")]),_._v(" "),r("td",[_._v("标记压缩")]),_._v(" "),r("td",[_._v("多CPU")])]),_._v(" "),r("tr",[r("td",[_._v("CMS")]),_._v(" "),r("td",[_._v("并发，几乎不会暂停用户线程")]),_._v(" "),r("td",[_._v("标记清除")]),_._v(" "),r("td",[_._v("多CPU且与用户线程共存")])])])]),_._v(" "),r("p",[r("RouterLink",{attrs:{to:"/pro016-JVM/lecture/chapter08/verse04.html"}},[_._v("上一节")]),_._v(" "),r("RouterLink",{attrs:{to:"/pro016-JVM/lecture/chapter08/index.html"}},[_._v("回目录")]),_._v(" "),r("RouterLink",{attrs:{to:"/pro016-JVM/lecture/chapter08/verse05.html"}},[_._v("下一节")])],1)])}),[],!1,null,null,null);v.default=a.exports}}]);