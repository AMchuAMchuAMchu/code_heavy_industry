(window.webpackJsonp=window.webpackJsonp||[]).push([[316],{1597:function(t,a,e){t.exports=e.p+"assets/img/img003.4f1719e1.png"},2386:function(t,a,e){"use strict";e.r(a);var r=e(54),s=Object(r.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("p"),r("div",{staticClass:"table-of-contents"},[r("ul",[r("li",[r("a",{attrs:{href:"#_1、本地接口-native-interface"}},[t._v("1、本地接口 Native Interface")])]),r("li",[r("a",{attrs:{href:"#_2、本地方法栈-native-method-stack"}},[t._v("2、本地方法栈 Native Method Stack")])]),r("li",[r("a",{attrs:{href:"#_2、程序计数器"}},[t._v("2、程序计数器")])]),r("li",[r("a",{attrs:{href:"#_3、执行引擎-execution-engine"}},[t._v("3、执行引擎 Execution Engine")])]),r("li",[r("a",{attrs:{href:"#_4、直接内存"}},[t._v("4、直接内存")]),r("ul",[r("li",[r("a",{attrs:{href:"#_1作用"}},[t._v("①作用")])]),r("li",[r("a",{attrs:{href:"#_2应用场景"}},[t._v("②应用场景")])]),r("li",[r("a",{attrs:{href:"#_3直接内存-堆外内存-与堆内存比较"}},[t._v("③直接内存（堆外内存）与堆内存比较")])])])])])]),r("p"),t._v(" "),r("h1",{attrs:{id:"第三章-总体机制中不重要的部分"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#第三章-总体机制中不重要的部分"}},[t._v("#")]),t._v(" 第三章 总体机制中不重要的部分")]),t._v(" "),r("h2",{attrs:{id:"_1、本地接口-native-interface"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1、本地接口-native-interface"}},[t._v("#")]),t._v(" 1、本地接口 Native Interface")]),t._v(" "),r("p",[t._v("本地接口的作用是融合不同的编程语言为 Java 所用，它的初衷是融合 C/C++程序。因为 Java 诞生的时候是 C/C++ 横行的时候，要想立足，必须有能力调用 C/C++。于是就在内存中专门开辟了一块区域处理标记为 native 的代码，它的具体做法是 Native Method Stack 中登记 native 方法，在Execution Engine 执行时加载 native libraies。")]),t._v(" "),r("p",[t._v("目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过 Java 程序驱动打印机或者 Java 系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用 Socket 通信，也可以使用 Web Service 等等，不多做介绍。")]),t._v(" "),r("h2",{attrs:{id:"_2、本地方法栈-native-method-stack"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2、本地方法栈-native-method-stack"}},[t._v("#")]),t._v(" 2、本地方法栈 Native Method Stack")]),t._v(" "),r("p",[t._v("专门负责在本地方法运行时，提供栈空间，存放本地方法每一次执行时创建的栈帧。它的具体做法是在 Native Method Stack 中登记 native 方法，在 Execution Engine 执行时加载本地方法库。")]),t._v(" "),r("p",[t._v("native 方法举例：")]),t._v(" "),r("div",{staticClass:"language-java line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-java"}},[r("code",[r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("native")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("yield")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[t._v("1")]),r("br")])]),r("h2",{attrs:{id:"_2、程序计数器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2、程序计数器"}},[t._v("#")]),t._v(" 2、程序计数器")]),t._v(" "),r("p",[t._v("也叫PC寄存器（"),r("span",{staticStyle:{color:"blue","font-weight":"bold"}},[t._v("P")]),t._v("rogram "),r("span",{staticStyle:{color:"blue","font-weight":"bold"}},[t._v("C")]),t._v("ounter Register）。用于保存程序执行过程中，下一条即将执行的指令的地址。也就是说能够保存程序当前已经执行到的位置。这个位置由执行引擎读取下一条指令，是一个非常小的内存空间，从内存空间使用优化这个角度来看：几乎可以忽略不记。")]),t._v(" "),r("h2",{attrs:{id:"_3、执行引擎-execution-engine"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3、执行引擎-execution-engine"}},[t._v("#")]),t._v(" 3、执行引擎 Execution Engine")]),t._v(" "),r("p",[t._v("作用：用于执行字节码文件中的指令。")]),t._v(" "),r("p",[t._v("执行指令的具体技术：")]),t._v(" "),r("ul",[r("li",[t._v("解释执行：第一代JVM。")]),t._v(" "),r("li",[t._v("即时编译：JIT，第二代JVM。")]),t._v(" "),r("li",[t._v("自适应优化：目前Sun的Hotspot JVM采用这种技术。吸取了第一代JVM和第二代JVM的经验，在一开始的时候对代码进行解释执行， 同时使用一个后台线程监控代码的执行。如果一段代码经常被调用，那么就对这段代码进行编译，编译为本地代码，并进行执行优化。若方法不再频繁使用，则取消编译过的代码，仍对其进行解释执行。")]),t._v(" "),r("li",[t._v("芯片级直接执行：内嵌在芯片上，用本地方法执行Java字节码。")])]),t._v(" "),r("h2",{attrs:{id:"_4、直接内存"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4、直接内存"}},[t._v("#")]),t._v(" 4、直接内存")]),t._v(" "),r("p",[r("img",{attrs:{src:e(1597),alt:"images"}})]),t._v(" "),r("h3",{attrs:{id:"_1作用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1作用"}},[t._v("#")]),t._v(" ①作用")]),t._v(" "),r("p",[t._v("提高特定场景下性能。")]),t._v(" "),r("h3",{attrs:{id:"_2应用场景"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2应用场景"}},[t._v("#")]),t._v(" ②应用场景")]),t._v(" "),r("p",[t._v("直接内存并不是虚拟机运行时数据区的一部分，也不是Java 虚拟机规范中定义的内存区域。在JDK1.4 中新加入了NIO(New Input/Output)类，引入了一种基于通道（Channel）与缓冲区（Buffer）的 I/O 方式，它可以使用native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。\n本机直接内存的分配不会受到 Java 堆大小的限制，受到本机总内存大小限制。\n配置虚拟机参数时，不要忽略直接内存防止出现 OutOfMemoryError 异常。")]),t._v(" "),r("h3",{attrs:{id:"_3直接内存-堆外内存-与堆内存比较"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3直接内存-堆外内存-与堆内存比较"}},[t._v("#")]),t._v(" ③直接内存（堆外内存）与堆内存比较")]),t._v(" "),r("p",[t._v("直接内存申请空间耗费更高的性能，当频繁申请到一定量时尤为明显。直接内存 I/O 读写的性能要优于普通的堆内存，在多次读写操作的情况下差异明显。")]),t._v(" "),r("p",[r("RouterLink",{attrs:{to:"/pro016-JVM/lecture/chapter02/index.html"}},[t._v("上一章")]),t._v(" "),r("RouterLink",{attrs:{to:"/pro016-JVM/lecture/index.html"}},[t._v("回目录")]),t._v(" "),r("RouterLink",{attrs:{to:"/pro016-JVM/lecture/chapter04/index.html"}},[t._v("下一章")])],1)])}),[],!1,null,null,null);a.default=s.exports}}]);